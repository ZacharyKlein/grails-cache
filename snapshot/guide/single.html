<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
                      "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
    <head>
        <title>cache 3.0.3.BUILD-SNAPSHOT</title>
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
        <link rel="stylesheet" href="../css/main.css" type="text/css" media="screen, print" title="Style" charset="utf-8" />
        <link rel="stylesheet" href="../css/pdf.css" type="text/css" media="print" title="PDF" charset="utf-8" />
    <script type="text/javascript">
function addJsClass(el) {
    var classes = document.body.className.split(" ");
    classes.push("js");
    document.body.className = classes.join(" ");
}
    </script>
    </head>

    <body class="body" onload="addJsClass();">
        <div id="navigation">
            <ul>
                <li>
                    <div id="nav-summary" onmouseover="toggleNavSummary(false)" onmouseout="toggleNavSummary(true)">
                        <a href="../guide/index.html" class="button">Table of contents</a>
                        <div id="nav-summary-childs" style="display:none;">
                            
                            <div class="toc-item" style="margin-left:0"><a href="#introduction"><strong>1</strong><span>Introduction To The Cache Plugin</span></a></div>
                            
                            <div class="toc-item" style="margin-left:0"><a href="#usage"><strong>2</strong><span>Usage</span></a></div>
                            
                            <div class="toc-item" style="margin-left:0"><a href="#cacheTags"><strong>3</strong><span>GSP Cache Tags</span></a></div>
                            
                            <div class="toc-item" style="margin-left:0"><a href="#grailsCacheAdminService"><strong>4</strong><span>Grails Cache Admin Service</span></a></div>
                            
                            <div class="toc-item" style="margin-left:0"><a href="#implementation"><strong>5</strong><span>Implementation Details</span></a></div>
                            
                        </div>
                    </div>
                </li>
                <li class="separator selected">
                    <a id="ref-button" onclick="localToggle(); return false;" href="#">Quick Reference</a>
                </li>
            </ul>
        </div>
        <div id="header">
            <div class="images clearfix">
                
                
            </div>
            <p></p>
        </div>


        <table id="colset" border="0" cellpadding="0" cellspacing="0">
            <tr>
                <td id="col1">
                    <div id="main" class="corner-all">

                        <span id='toggle-col1' class="toggle">(<a href="#" onclick="localToggle(); return false;">Quick Reference</a>)</span>

                        <div class="project">
                            <h1>cache - Reference Documentation</h1>
                            <p><strong>Authors:</strong> </p>
                            <p><strong>Version:</strong> 3.0.3.BUILD-SNAPSHOT</p>
                            
                        </div>

                        
                        <div id="table-of-content">
                            <h2>Table of Contents</h2>
                            
                            <div class="toc-item" style="margin-left:0px"><a href="#introduction"><strong>1</strong><span>Introduction To The Cache Plugin</span></a></div>
                            
                            <div class="toc-item" style="margin-left:10px"><a href="#changeLog"><strong>1.1</strong><span>Change log</span></a></div>
                            
                            <div class="toc-item" style="margin-left:0px"><a href="#usage"><strong>2</strong><span>Usage</span></a></div>
                            
                            <div class="toc-item" style="margin-left:10px"><a href="#configuration"><strong>2.1</strong><span>Configuration</span></a></div>
                            
                            <div class="toc-item" style="margin-left:10px"><a href="#dsl"><strong>2.2</strong><span>Cache DSL</span></a></div>
                            
                            <div class="toc-item" style="margin-left:10px"><a href="#annotations"><strong>2.3</strong><span>Annotations</span></a></div>
                            
                            <div class="toc-item" style="margin-left:10px"><a href="#cacheManager"><strong>2.4</strong><span>CacheManager</span></a></div>
                            
                            <div class="toc-item" style="margin-left:0px"><a href="#cacheTags"><strong>3</strong><span>GSP Cache Tags</span></a></div>
                            
                            <div class="toc-item" style="margin-left:0px"><a href="#grailsCacheAdminService"><strong>4</strong><span>Grails Cache Admin Service</span></a></div>
                            
                            <div class="toc-item" style="margin-left:10px"><a href="#clearingCaches"><strong>4.1</strong><span>Clearing Caches</span></a></div>
                            
                            <div class="toc-item" style="margin-left:0px"><a href="#implementation"><strong>5</strong><span>Implementation Details</span></a></div>
                            
                            <div style="clear:both" ></div>
                        </div>
                        
                        
<a name="1. Introduction To The Cache Plugin"><!-- Legacy link --></a>
<h1 id="introduction">1 Introduction To The Cache Plugin</h1>
The Grails Cache plugin provides powerful and easy to use caching functionality to Grails applications and plugins.<p class="paragraph"/>The plugin makes significant use of the caching abstraction provided by Spring 3.1.  This user guide will focus on taking advantage of that functionality specifically within the context of a Grails application.  For information on the underlying abstraction see <a href="http://static.springsource.org/spring/docs/3.1.x/spring-framework-reference/html/cache.html" target="blank">The Official Spring Documentation</a>.


<a name="1.1 Change log"><!-- Legacy link --></a>
<h2 id="changeLog">1.1 Change log</h2>
<h3>Version 1.1.7 - June 24, 2014</h3>
Requires Grails 2.3 or later
<h3>Version 1.1.6 - May 9, 2014</h3>
<h3>Version 1.1.5 - April 25, 2014</h3>
<h3>Version 1.1.4 - April 25, 2014</h3>
<h3>Version 1.1.3 - April 24, 2014</h3>
<h3>Version 1.1.2 - April 23, 2014</h3>
<h3>Version 1.1.1 - July 3, 2013</h3>
<h3>Version 1.1 - July 3, 2013</h3>
<h3>Version 1.0.1 - October 28, 2012</h3>
<h3>Version 1.0.0 - July 4, 2012</h3>
<h3>Version 1.0.0.RC1 - May 22, 2012</h3>
<h3>Version 1.0.0.M2 - May 12, 2012</h3>



<h1 id="usage">2 Usage</h1>
The cache plugin adds Spring bean method call, controller action, and GSP page fragment and template caching to Grails applications. You configure one or more caches in <code>Config.groovy</code> and/or one or more Groovy artifact files with names ending in CacheConfig.groovy (for example FooCacheConfig.groovy, BarCacheConfig.groovy, and these can also be in packages) in <code>grails-app/conf</code> (or a subdirectory if in a package) using an implementation-specific DSL, and annotate methods (either in Spring beans (typically Grails services) or controllers) to be cached. You can also wrap GSP sections in cache tags and render cached templates.<p class="paragraph"/>There are three annotations; <a href="../api/grails/plugin/cache/Cacheable.html" class="api">Cacheable</a>, <a href="../api/grails/plugin/cache/CachePut.html" class="api">CachePut</a>, and <a href="../api/grails/plugin/cache/CacheEvict.html" class="api">CacheEvict</a>. You use &#64;Cacheable to mark a method as one that should check the cache for a pre-existing result, or generate a new result and cache it. Use &#64;CachePut to mark a method as one that should always be evaluated and store its result in the cache regardless of existing cache values. And use &#64;CacheEvict to flush a cache (either fully or partially) to force the re-evaluation of previously cached results. The annotations are based on the annotations with the same name from Spring (<a href="http://static.springsource.org/spring/docs/3.1.x/javadoc-api/org/springframework/cache/annotation/Cacheable.html" target="blank">Cacheable</a>, <a href="http://static.springsource.org/spring/docs/3.1.x/javadoc-api/org/springframework/cache/annotation/CachePut.html" target="blank">CachePut</a>, and <a href="http://static.springsource.org/spring/docs/3.1.x/javadoc-api/org/
springframework/cache/annotation/CacheEvict.html" target="blank">CacheEvict</a>) and support the same syntax but may support extended functionality in the future.<p class="paragraph"/>When using distributed caching (such as ehcache with distributed cache enabled, or redis with multiple instances of the application running against one redis instance), all classes that use annotation caching or XML caching should override the <code>hashCode</code> method. The hash code of the object with the method marked as being cacheable is included in the cache key, and the default <code>hashCode</code> implementation will vary each time the application is run. Overriding <code>hashCode</code> ensures that each instance of the applications will appropriately share cache keys.<p class="paragraph"/>This 'core' cache plugin uses an in-memory implementation where the caches and cache manager are backed by a thread-safe <code>java.util.concurrent.ConcurrentMap</code>. This is fine for testing and possibly for low-traffic sites, but you should consider using one of the extension plugins if you need clustering, disk storage, persistence between restarts, and more configurability of features like time-to-live, maximum cache size, etc. Currently the extension plugins include <a href="http://grails.org/plugin/cache-ehcache" target="blank">cache-ehcache</a>, <a href="http://grails.org/plugin/cache-redis" target="blank">cache-redis</a>, and <a href="http://grails.org/plugin/cache-gemfire" target="blank">cache-gemfire</a>.



<h2 id="configuration">2.1 Configuration</h2>
<h4>Config.groovy and artifact files</h4><p class="paragraph"/>The caching configuration can be specified in <code>Config.groovy</code> or &#42;CacheConfig.groovy files. Both approaches support <code>environments</code> blocks for environment-specific configuration, and you can specify the loading order, for example to support overriding values. One example of this might be a plugin that specifies a known load order, allowing you to choose a lower value in your file and override some or all of the plugin's configuration.<p class="paragraph"/>There are a few configuration options for the plugin; these are specified in <code>Config.groovy</code>.<p class="paragraph"/><table class="wiki-table" cellpadding="0" cellspacing="0" border="0"><tr><th><strong class="bold">Property</strong></th><th><strong class="bold">Default</strong></th><th><strong class="bold">Description</strong></th></tr><tr class="table-odd"><td>grails.cache.enabled</td><td><code>true</code></td><td>Whether to enable the plugin</td></tr><tr class="table-even"><td>grails.cache.proxyTargetClass</td><td><code>false</code></td><td>From the Spring Javadoc: "By default, all proxies are created as JDK proxies. This may cause some problems if you are injecting objects as concrete classes rather than interfaces. To overcome this restriction you can set the <code>proxy-target-class</code> attribute to <code>true</code> which will result in class-based proxies being created."</td></tr><tr class="table-odd"><td>grails.cache.aopOrder</td><td>Ordered.LOWEST_PRECEDENCE</td><td>From the Spring docs: "Defines the order of the cache advice that is applied to beans annotated with &#64;Cacheable or &#64;CacheEvict. No specified ordering means that the AOP subsystem determines the order of the advice."</td></tr><tr class="table-even"><td>grails.cache.clearAtStartup</td><td><code>false</code></td><td>Whether to clear all caches at startup</td></tr><tr class="table-odd"><td>grails.cache.keyGenerator</td><td>"customCacheKeyGenerator"</td><td>Replace the key generator with your own. e.g. if your config is <code>grails.cache.keyGenerator="myCacheKeygen"</code>, you would declare something like this <code>myCacheKeygen(my.company.MyKeyGen)</code> in your resources.groovy. Note: MyKeyGen must implement KeyGenerator.</td></tr><tr class="table-even"><td>grails.cache.cacheManager</td><td>"GrailsConcurrentMapCacheManager"</td><td>Cache Manager to use. Default cache manager uses Spring Frameworks ConcurrentMapCache which might grow limitless. If you cannot predict how many cache entries you are going to generate use "GrailsConcurrentLinkedMapCacheManager" instead which uses com.googlecode.concurrentlinkedhashmap.ConcurrentLinkedHashMap and limits by default to 10000 entries per cache.</td></tr></table>



<h2 id="dsl">2.2 Cache DSL</h2>
The cache implementation used by this plugin is very simple, so there aren't many configuration options (compared to the Ehcache implementation for example, where you have fine-grained control over features like overflowing to disk, time-to-live settings, maximum size of caches, etc.) So there aren't many supported options in the cache configuration DSL, although each plugin's DSL parser is lenient and just logs warnings if you specify options that aren't understood. This lets you share configurations between applications that use different plugins.<p class="paragraph"/><blockquote class="warning">
Since there is no way to configure "time to live" with this plugin, all cached items have no timeout and remain cached until either the JVM restarts (since the backing store is in-memory) or the cache is partially or fully cleared (by calling a method or action annotated with &#64;CacheEvict or programmatically).
</blockquote><p class="paragraph"/>You specify the cache configuration in <code>Config.groovy</code> under the <code>grails.cache.config</code> key, for example<p class="paragraph"/><div class="code"><pre>grails.cache.config = &#123;
   cache &#123;
      name 'message'
   &#125;
   cache &#123;
      name 'maps'
   &#125;
&#125;</pre></div><p class="paragraph"/>or in a &#42;CacheConfig.groovy file in the <code>grails-app/conf</code> directory under the <code>config</code> key, for example<p class="paragraph"/><div class="code"><pre>config = &#123;
   cache &#123;
      name 'message'
   &#125;
   cache &#123;
      name 'maps'
   &#125;
&#125;</pre></div><p class="paragraph"/>Both of these will create two caches, one with name "message" and one with name "maps". You can also use attributes from other DSLs and they will be ignored, for example:<p class="paragraph"/><div class="code"><pre>grails.cache.config = &#123;
   cache &#123;
      name 'message'
      eternal <span class="java&#45;keyword">false</span>
      overflowToDisk <span class="java&#45;keyword">true</span>
      maxElementsInMemory 10000
      maxElementsOnDisk 10000000
   &#125;
   cache &#123;
      name 'maps'
   &#125;
&#125;</pre></div><p class="paragraph"/>This configuration results in the same caches as the simpler one.<p class="paragraph"/>If you want to limit the number of cache entries you have to change the default cache manager to <code>'GrailsConcurrentLinkedMapCacheManager'</code>. To specify the limit you can add the <code>maxCapacity</code> parameter to the cache config. Default value for <code>maxCapacity</code> is 10000.<p class="paragraph"/><div class="code"><pre>grails.cache.config = &#123;
   cacheManager 'GrailsConcurrentLinkedMapCacheManager'
   cache &#123;
      maxCapacity = 5000
      name 'message'
   &#125;
   cache &#123;
      maxCapacity = 6000
      name 'maps'
   &#125;
&#125;</pre></div><p class="paragraph"/><h4>Order</h4><p class="paragraph"/>You can configure your cache definitions to be loaded before or after others by setting the <code>order</code> attribute. Configurations with higher numbers are loaded later, so these can override previously-configured values, although there is no support for removing caches or cache attributes, only adding or overriding:<p class="paragraph"/><div class="code"><pre>order = 2000<p class="paragraph"/>config = &#123;
   cache &#123;
      name 'message'
   &#125;
   cache &#123;
      name 'maps'
   &#125;
&#125;</pre></div>



<h2 id="annotations">2.3 Annotations</h2>
The <a href="../api/grails/plugin/cache/Cacheable.html" class="api">Cacheable</a> and <a href="../api/grails/plugin/cache/CacheEvict.html" class="api">CacheEvict</a> annotations provided by the plugin have counterparts with the same names provided by Spring. See the <a href="http://static.springsource.org/spring/docs/3.1.x/spring-framework-reference/html/cache.html" target="blank">Spring documentation</a> for their usage and allowed syntax.<p class="paragraph"/><h4>Service method caching</h4><p class="paragraph"/>Given this simple service, you can see that the <code>getMessage</code> method is configured to cache the results in the <code>"message"</code> cache. The <code>title</code> parameter will be used as the cache key; if there were multiple parameters they would be combined into the key, and you can always specify the key using the Spring SpEL support. The <code>save</code> method is configured as one that evicts elements from the cache. There is no need to clear the entire cache in this case; instead any previously cached item with the same <code>title</code> attribute will be replaced with the current <code>Message</code> instance.<p class="paragraph"/><div class="code"><pre><span class="java&#45;keyword">package</span> com.yourcompany<p class="paragraph"/><span class="java&#45;keyword">import</span> grails.plugin.cache.CacheEvict
<span class="java&#45;keyword">import</span> grails.plugin.cache.Cacheable<p class="paragraph"/>class MessageService &#123;<p class="paragraph"/>   @Cacheable('message', key='&#35;title')
   Message getMessage(<span class="java&#45;object">String</span> title) &#123;
      println 'Fetching message'
      Message.findByTitle(title)
   &#125;<p class="paragraph"/>   @CachePut(value='message', key='&#35;message.title')
   void save(Message message) &#123;
      println <span class="java&#45;quote">"Saving message $message"</span>
      message.save()
   &#125;<p class="paragraph"/>   @CacheEvict(value='message', key='&#35;message.title')
   void delete(Message message) &#123;
      println <span class="java&#45;quote">"Deleting message $message"</span>
      message.delete()
   &#125;
&#125;</pre></div><p class="paragraph"/>Note that you could also use &#64;CacheEvict for the <code>save</code> method, which would remove the old cached value but not cache the current value.<p class="paragraph"/>This service works with the <code>Message</code> domain class:<p class="paragraph"/><div class="code"><pre><span class="java&#45;keyword">package</span> com.yourcompany<p class="paragraph"/>class Message <span class="java&#45;keyword">implements</span> Serializable &#123;<p class="paragraph"/>   <span class="java&#45;keyword">private</span> <span class="java&#45;keyword">static</span> <span class="java&#45;keyword">final</span> <span class="java&#45;object">long</span> serialVersionUID = 1<p class="paragraph"/>   <span class="java&#45;object">String</span> title
   <span class="java&#45;object">String</span> body<p class="paragraph"/>   <span class="java&#45;object">String</span> toString() &#123;
      <span class="java&#45;quote">"$title: $body"</span>
   &#125;
&#125;</pre></div><p class="paragraph"/>Note that for in-memory cache implementations it's not required that the objects being cached implement <code>Serializable</code> but if you use an implementation that uses Java serialization (for example the Redis plugin, or the Ehcache plugin when you have configured clustered caching) you must implement <code>Serializable</code>.<p class="paragraph"/>To test this out, be sure to define a <code>"message"</code> cache in <code>Config.groovy</code> and save and retrieve <code>Message</code> instances using the service. There are <code>println</code> statements but you can also turn on SQL logging to watch the database access that's needed to retrieve instances that aren't cached yet, and you shouldn't see database access for cached values.<p class="paragraph"/><h4>Controller action caching</h4><p class="paragraph"/>In addition to caching Spring bean return values, you can also cache responses for web requests using the same annotations. Note that since caching is implemented only for methods (Spring creates a proxy for your cached class in the same way that it creates a transactional proxy to start, commit, and roll back transactions for transactional Grails services) so you cannot annotate action closures. This doesn't fail silently; your controller class will not compile since the annotations are only allowed on the class or on methods; since Closures are fields, the annotations aren't valid.<p class="paragraph"/>For example, in this controller the <code>lookup</code> action will use the <code>"message"</code> cache, so the first time you call the action you will see the output from the <code>println</code> statement but subsequent calls won't execute and you'll see the cached response instead. When you call the <code>evict</code> action the entire cache will be cleared (because of the <code>allEntries=true</code> attribute):<p class="paragraph"/><div class="code"><pre><span class="java&#45;keyword">package</span> com.yourcompany<p class="paragraph"/><span class="java&#45;keyword">import</span> grails.plugin.cache.CacheEvict
<span class="java&#45;keyword">import</span> grails.plugin.cache.Cacheable<p class="paragraph"/>class TestController &#123;<p class="paragraph"/>   @Cacheable('message')
   def lookup() &#123;
      // perform some expensive operations
      println <span class="java&#45;quote">"called 'lookup'"</span>
   &#125;<p class="paragraph"/>   @CacheEvict(value='message', allEntries=<span class="java&#45;keyword">true</span>)
   def evict() &#123;
      println <span class="java&#45;quote">"called 'evict'"</span>
   &#125;
&#125;</pre></div><p class="paragraph"/><blockquote class="note">
Caching of dynamically scaffolded actions is not supported.  If the scaffolding templates are installed with <code>grails install-templates</code> and cache related annotations are added to methods in the controller template, those annotations will only be relevant to generated scaffolding, not dynamic scaffolding.
</blockquote><p class="paragraph"/><h4>If you can't use annotations</h4><p class="paragraph"/>Annotations aren't required, they're just the most convenient approach for configuration. If you like you can define caching semantics in <code>grails-app/conf/spring/resources.groovy</code> (or <code>resources.xml</code> if you like XML). This is also useful if you want to apply caching but can't edit the code to add annotations (for example if you have compiled classes in a jar).<p class="paragraph"/>This Spring BeanBuilder DSL code will configure the same behavior as the two annotations in the example service class:<p class="paragraph"/><div class="code"><pre>beans = &#123;<p class="paragraph"/>   xmlns cache: 'http://www.springframework.org/schema/cache'
   xmlns aop: 'http://www.springframework.org/schema/aop'<p class="paragraph"/>   cache.'advice'(id: 'messageServiceCacheAdvice',
                  'cache&#45;manager': 'grailsCacheManager') &#123;
      caching(cache: 'message') &#123;
         cacheable(method: 'getMessage')
         'cache&#45;evict'(method: 'save', key: '&#35;message.title')
      &#125;
   &#125;<p class="paragraph"/>   // apply the cacheable behavior to MessageService
   aop.config &#123;
      advisor('advice&#45;ref': 'messageServiceCacheAdvice',
              pointcut: 'execution(&#42; com.yourcompany.MessageService.&#42;(..))')
   &#125;
&#125;</pre></div>



<h2 id="cacheManager">2.4 CacheManager</h2>
The plugin registers an instance of the <a href="http://static.springsource.org/spring/docs/3.1.x/javadoc-api/org/springframework/cache/CacheManager.html" target="blank">CacheManager</a> iterface as the <code>grailsCacheManager</code> Spring bean, so it's easy to access using dependency injection.<p class="paragraph"/>The most common method you would call on the <code>grailsCacheManager</code> is <code>getCache(String name)</code> to access a <a href="http://static.springsource.org/spring/docs/3.1.x/javadoc-api/org/springframework/cache/Cache.html" target="blank">Cache</a> instance programmatically. This shouldn't be needed often however. From the <code>Cache</code> instance you can also access the underlying cache implementation using <code>cache.getNativeCache()</code>.


<h1 id="cacheTags">3 GSP Cache Tags</h1>
The plugin provides GSP tags which are useful for caching the result of evaluating sections of markup.  These tags allow for the result of evaluating sections of markup to be cached so subsequent renderings of the same markup do not have to result in the markup being evaluated again.  These tags support automatic cache eviction with the use of a time to live (ttl) attribute.<p class="paragraph"/>See the documentation for the <a href="../ref/Tags/block.html" class="tags">block</a> and <a href="../ref/Tags/render.html" class="tags">render</a> tags for more details.


<h1 id="grailsCacheAdminService">4 Grails Cache Admin Service</h1>
The plugin provides a service named <code>GrailsCacheAdminService</code> which supports various methods for administering caches.


<h2 id="clearingCaches">4.1 Clearing Caches</h2>
There are methods in GrailsCacheAdminService for clearing the caches used by the <a href="../ref/Tags/block.html" class="tags">block</a> and <a href="../ref/Tags/render.html" class="tags">render</a> tags.<p class="paragraph"/><div class="code"><pre>class ReportingController &#123;<p class="paragraph"/>    def grailsCacheAdminService<p class="paragraph"/>    def report() &#123;
        // clear the cache used by the blocks tag&#8230;
        grailsCacheAdminService.clearBlocksCache()<p class="paragraph"/>        // clear the cache used by the render tag&#8230;
        grailsCacheAdminService.clearTemplatesCache()<p class="paragraph"/>        &#8230;
    &#125;
&#125;</pre></div>


<h1 id="implementation">5 Implementation Details</h1>
All of the plugin's classes are designed for extensibility; the classes are all public, and fields and methods are mostly public or protected. Consider subclassing existing classes to reuse as much as possible instead of completely rewriting them.<p class="paragraph"/><h4>Cache manager</h4><p class="paragraph"/>The core cache plugin registers a <code>grailsCacheManager</code> Spring bean, and the extension plugins replace this bean with one that creates and manages caches for that implementation. The default implementation is an instance of <code>grails.plugin.cache.GrailsConcurrentMapCacheManager</code> which uses <code>grails.plugin.cache.GrailsConcurrentMapCache</code> as its cache implementation. It uses a <code>java.util.concurrent.ConcurrentHashMap</code> to store cached values.<p class="paragraph"/>You can customize the cache manager by replacing the <code>grailsCacheManager</code> Spring bean in <code>resources.groovy</code> with your own; either subclass <code>GrailsConcurrentMapCacheManager</code> (e.g. to override the <code>createConcurrentMapCache()</code> method) or by implementing the <code>grails.plugin.cache.GrailsCacheManager</code> interface.<p class="paragraph"/><h4>Controller caching</h4><p class="paragraph"/>The controller caching is implemented with a filter registered as <code>grailsCacheFilter</code> in <code>web.xml</code> and it is backed by the Spring bean of the same name. The implementation class is <code>grails.plugin.cache.web.filter.simple.MemoryPageFragmentCachingFilter</code>.<p class="paragraph"/>The content that is cached is the response generated by GSP (or directly by the controller if a response is rendered programmatically) before Sitemesh applies its template(s).<p class="paragraph"/><h5>Key generation</h5><p class="paragraph"/>Controller caching uses a key generator, a class that implements the <code>grails.plugin.cache.web.filter.WebKeyGenerator</code> interface (by default a <code>grails.plugin.cache.web.filter.DefaultWebKeyGenerator</code>). This is registered as the <code>webCacheKeyGenerator</code> Spring bean, so customizing the key generation is simply a matter of subclassing <code>DefaultWebKeyGenerator</code> or re-implementing the interface and registering your own <code>webCacheKeyGenerator</code> bean in <code>resources.groovy</code>.<p class="paragraph"/><h4>Fragment caching</h4><p class="paragraph"/>You can cache partial GSP page sections with the <code>&#60;cache:block&#62;</code> tag. You can specify a key when using this tag but it's in general unnecessary. This is because the block will be rendered with its own Closure, and the default key is the full closure class name. This is unique since the closures aren't re-used; for example these two blocks will be cached independently, even in the same GSP:<p class="paragraph"/><div class="code"><pre>&#60;cache:block&#62;
foo
&#60;/cache:block&#62;<p class="paragraph"/>&#60;cache:block&#62;
bar
&#60;/cache:block&#62;</pre></div><p class="paragraph"/>You can cache the content of templates with the <code>&#60;cache:render&#62;</code> tag. You can specify a key when using this tag but like the <code>block</code> tag, it's in general unnecessary because the default key is the full template class name.<p class="paragraph"/><h4>Service caching</h4><p class="paragraph"/>You can cache the return value of a service method by annotating it with <code>Cacheable</code>.<p class="paragraph"/><h5>Key generation</h5><p class="paragraph"/>The default implementation of the <code>org.springframework.cache.interceptor.KeyGenerator</code> used to generate keys for service method calls is <code>org.springframework.cache.interceptor.DefaultKeyGenerator</code>. This is only used if there is no <code>key</code> attribute specified in the annotation for the method. It generates a numeric key, with the following logic:<p class="paragraph"/><div class="code"><pre><span class="java&#45;keyword">public</span> <span class="java&#45;object">Object</span> generate(<span class="java&#45;object">Object</span> target, Method method, <span class="java&#45;object">Object</span>&#8230; params) &#123;
   <span class="java&#45;keyword">if</span> (params.length == 1) &#123;
      <span class="java&#45;keyword">return</span> (params&#91;0&#93; == <span class="java&#45;keyword">null</span> ? 53 : params&#91;0&#93;);
   &#125;<p class="paragraph"/>   <span class="java&#45;keyword">if</span> (params.length == 0) &#123;
      <span class="java&#45;keyword">return</span> 0;
   &#125;<p class="paragraph"/>   <span class="java&#45;object">int</span> hashCode = 17;
   <span class="java&#45;keyword">for</span> (<span class="java&#45;object">Object</span> object : params) &#123;
      hashCode = 31 &#42; hashCode + (object == <span class="java&#45;keyword">null</span> ? 53 : object.hashCode());
   &#125;
   <span class="java&#45;keyword">return</span> hashCode;
&#125;</pre></div><p class="paragraph"/>This is very generic and somewhat risky, since two no-arg methods that use the same cache will store values under the same key (0), and different methods with similar signatures can easily generate the same key for different return values. So it's best to either specify the <code>key</code> attribute in the annotation, or use separate caches.<p class="paragraph"/><h4>DSL parsing</h4><p class="paragraph"/>The cache plugin's DSL is very basic; only the cache name can be specified. But you could extend it (for example if you customized the cache or cache manager implementation, although a new plugin would probably make more sense) by replacing the <code>grailsCacheConfigLoader</code> Spring bean in <code>resources.groovy</code>. The default implementation is a <code>grails.plugin.cache.ConfigLoader</code>.<p class="paragraph"/><h4>Annotation SpEL expression evaluator</h4><p class="paragraph"/>You can extend or customize what is SpEL expressions are supported by re-defining the <code>webExpressionEvaluator</code> Spring bean in <code>resources.groovy</code>. The default implementation is an instance of <code>grails.plugin.cache.web.filter.ExpressionEvaluator</code>.


                    </div>
                </td>
                <td id="col2">
            <div class="local clearfix">
                <div class="local-title">
                    <a href="../guide/index.html" target="mainFrame">Quick Reference</a>
                    <span class="toggle">(<a href="#" onclick="localToggle(); return false;">hide</a>)</span>
                </div>
                <div class="menu">
                    
                    <div class="menu-block"><h1 class="menu-title" onclick="toggleRef(this.parentNode.childNodes[1])">Tags</h1><div class="menu-sub">
                        
                        
                        <div class="menu-item"><a href="../ref/Tags/block.html">block</a>
                        </div>
                        
                        <div class="menu-item"><a href="../ref/Tags/render.html">render</a>
                        </div>
                        
                        </div>
                    </div>
                    
                </div>
            </div>
        </td>
            </tr>
        </table>

        <div id="footer">
            
            
        </div>



<script type="text/javascript" src="../js/docs.js"></script>

    </body>
</html>
